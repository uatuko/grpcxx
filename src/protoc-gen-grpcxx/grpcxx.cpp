#include "grpcxx.h"

#include <fmt/core.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream.h>

#include <memory>
#include <string>

bool Grpcxx::Generate(
	const google::protobuf::FileDescriptor *file, const std::string &parameter,
	google::protobuf::compiler::GeneratorContext *context, std::string *error) const {

	std::string output = fmt::format(
		R"(// Code generated by {0}.
// Versions:
//   - {0}: v{1}
// Source: {2}

#pragma once

#include <grpcxx/rpc.h>
#include <grpcxx/service.h>

#include "{3}"
)",
		PLUGIN_NAME,
		PLUGIN_VERSION,
		file->name(),
		google::protobuf::compiler::StripProto(file->name()) + ".pb.h");

	if (!file->package().empty()) {
		output += '\n';

		std::size_t start = 0;
		for (auto end = file->package().find('.'); end != std::string::npos;
			 end      = file->package().find('.', start)) {

			output += fmt::format("namespace {} {{\n", file->package().substr(start, end - start));
			start   = end + 1;
		}
		output += fmt::format("namespace {} {{\n", file->package().substr(start));
	}

	for (int i = 0; i < file->service_count(); i++) {
		auto service  = file->service(i);
		output       += fmt::format("namespace {} {{\n", service->name());

		std::string tmp = fmt::format(
			"using Service = grpcxx::service<\"{}{}{}\"",
			file->package(),
			file->package().empty() ? "" : ".",
			service->name());

		for (int j = 0; j < service->method_count(); j++) {
			auto method = service->method(j);

			// Map proto types to c++ types
			// e.g. `google.protobuf.Empty` -> `google::protobuf::Empty`
			auto mapper = [&file](const google::protobuf::Descriptor *t) -> std::string {
				auto name = t->full_name();
				if (!file->package().empty() && name.starts_with(file->package())) {
					name = name.substr(file->package().size() + 1);
				}

				std::string result;
				std::size_t start = 0;
				for (auto end = name.find('.'); end != std::string::npos;
					 end      = name.find('.', start)) {
					result += name.substr(start, end - start) + "::";
					start   = end + 1;
				}
				result += name.substr(start);

				return result;
			};

			output += fmt::format(
				"using rpc{0} = grpcxx::rpc<\"{0}\", {1}, {2}>;\n\n",
				method->name(),
				mapper(method->input_type()),
				mapper(method->output_type()));

			tmp += fmt::format(", rpc{}", method->name());
		}

		output += tmp + ">;\n\n";

		output += R"(struct ServiceImpl {
	template <typename T>
	typename T::result_type call(grpcxx::context &, const typename T::request_type &) {
		return {grpcxx::status::code_t::unimplemented, std::nullopt};
	}
};
)";
		output += fmt::format("}} // namespace {}\n", service->name());
	}

	if (!file->package().empty()) {
		auto end = file->package().size();
		for (auto pos = file->package().rfind('.'); pos != std::string::npos;
			 pos      = file->package().rfind('.', end)) {

			output +=
				fmt::format("}} // namespace {}\n", file->package().substr(pos + 1, end - pos));
			end = pos - 1;
		}
		output += fmt::format("}} // namespace {}\n", file->package().substr(0, end + 1));
	}

	std::unique_ptr<google::protobuf::io::ZeroCopyOutputStream> ostream(
		context->Open(google::protobuf::compiler::StripProto(file->name()) + ".grpcxx.pb.h"));

	google::protobuf::io::CodedOutputStream costream(ostream.get());
	costream.WriteRaw(output.data(), output.size());

	return true;
}
